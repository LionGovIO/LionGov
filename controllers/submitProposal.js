
let ControllerClass = require('../libs/ControllerClass');

const { v4: uuidv4 } = require('uuid');
const ethers = require('ethers');

module.exports = class submitProposal extends ControllerClass {

  _submitProposal = (data, callback) => {

    this.debug("########################## submitProposal !!!!!!!!!!!!!!!!!!");

    var proposalId = uuidv4();
    var walletAddress = data.walletAddress;
    var proposalType = "yes_no"; // only one proposal type right now
    var title = data.title.trim();
    var description = data.description.trim();
    // TODO: add length limits on title, description, etc.

    walletAddress = walletAddress.trim().toLowerCase();
    this.debug('walletAddress to submitProposal of! ' + walletAddress);


    // TODO: trim inputs of whitespaces, or reject inputs with whitespace padding
    var conditionExpression = 'attribute_not_exists(ProposalId)';
    this.debug('conditionExpression: ' + conditionExpression);

    // TODO: consider generating / storing a vote ID anyway, could be part of signature calculation
    // or instead of called vote ID, it can be some hash salt generated by the server, to be determined


    // Note, for the Votes table:
    // Partition key is VoteClass
    // Sort key is WalletAddress
    var params = {
      TableName: "Proposals",
      Item: {
        "ProposalId": {
          S: proposalId
        },
        "WalletAddress": {
          S: walletAddress
        },
        "ProposalType": {
          S: proposalType
        },
        "Title": {
          S: title
        },
        "Description": { // TODO: description might be deprecated in future, might want to be a more flexible body input
          S: description
        },
        "CreationTime": {
          S: data.timestamp.toString()
        }
      },
      ConditionExpression: conditionExpression
    };

    this.debug('params!!!');
    this.debug(params);

    dynamoDB.putItem(params, function(err, data) {
      if (err) {
        console.log(err);
        if (err.code == 'ConditionalCheckFailedException') {
          err.msg = 'Primary key is already in use';
        } else {
          err.msg = err.message;
        }

        err.class = "DynamoDB";
        callback({
          error: err
        }, null);

      } else {
        callback(null, {proposalId: proposalId});
      }
    });

  }


  post = (req, res) => {

    var postData = req.body;
    let checksumAddress = null;
    //then work with your data

    this.debug('submitproposal postData!');
    this.debug(postData);

    try {
      checksumAddress = ethers.utils.getAddress(postData.walletAddress); //EIP55
      if (!checksumAddress) {
        res.json({
          "error": {msg: "No address informed!"}
        });
        res.end();
        return;
      }
    } catch (e) {
      res.json({
        "error": {msg: "Invalid Address!"}
      });
      res.end();
      return;
    }

    let signature_valid_for = 5 * 60 * 1000; //5 min in milliseconds

    if (postData.timestamp < (Date.now() - signature_valid_for)){
      res.json({
        "error": {msg: 'Signature expired! Try submitting again or checking your system clock.'}
      });
      res.end();
      return;
    }

    let message = "New proposal:\n" +
                  'Title: ' + postData.title + "\n" +
                  'Description: ' + postData.description + "\n" +
                  'Timestamp: ' + postData.timestamp;

    // verifyMessage (Message , signature) -> return in EIP55 address

    if (checksumAddress != ethers.utils.verifyMessage(message, postData.signature)) {
      res.json({ "error": "Invalid signature!" });
      res.end();
      return;
    }

    let voteWeightInfo = Blkchain.getVoteWeight(postData.walletAddress, Date.now());

    let voteWeight = voteWeightInfo.voteWeight;

    if(voteWeight < 100){
      res.json({
        "error": {msg: "You need to have a point weight of 100 or higher to create a proposal.\n" +
                       "Your current point weight is: " + voteWeight }
      });
      res.end();
      return;
    }

    // TODO: reject invalid post params
    // prevent bad data from being injected in database

    // TODO: make sure the signature on the voting data is deterministic
    // e.g. the wallet address lowercased/normalized with Web3.utils.toChecksumAddress

    this._submitProposal(postData, function(err, result) {
      console.log('submitProposal callback!');
      console.log(err);
      console.log(result);

      if (err) {
        res.json(err);
        res.end();
        return;
      }
      if (result) {
        res.json(result);
        res.end();
        return;
      }

    });

  }
}
