<!doctype html>
<html lang="en">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <title>LionGov</title>

    <link rel="icon" type="image/svg+xml" href="/favicon.svg">

    <!-- TODO: use integrity on all the CDNs to improve security -->

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css"
        integrity="sha384-B0vP5xmATw1+K9KRQjQERJvTumQW0nPEzvF6L/Z6nronJ3oUOFUFpCjEUQouq2+l" crossorigin="anonymous">

    <!-- JQuery + Bootstrap, order of script imports matters -->
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"
        integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"
        integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js"
        integrity="sha384-+YQ4JLhjyBLPDQt//I+STsc9iw4uQqACwlvpslubQzn4u2UU2UFM80nGisd026JF"
        crossorigin="anonymous"></script>

    <script src="https://cdn.ethers.io/lib/ethers-5.2.umd.min.js" type="application/javascript"></script>

    <script type="text/javascript" src="https://unpkg.com/web3@latest/dist/web3.min.js"></script>
    <script type="text/javascript" src="https://unpkg.com/web3modal@1.9.4/dist/index.js"></script>
    <script type="text/javascript" src="https://unpkg.com/evm-chains@0.2.0/dist/umd/index.min.js"></script>
    <script type="text/javascript"
        src="https://unpkg.com/@walletconnect/web3-provider@1.6.5/dist/umd/index.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.5.1/chart.min.js"
        integrity="sha512-Wt1bJGtlnMtGP0dqNFH1xlkLBNpEodaiQ8ZN5JLA5wpc1sUlk/O5uuOMNgvzddzkpvZ9GLyYNa8w2s7rqiTk5Q=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>


    <script>
        const hardcodedProposal = '422ad39a-781e-4321-b3d0-7ee63bbcd29e';

        function init() {

            var web3 = null;
            var provider = null;

            // Unpkg imports
            const Web3Modal = window.Web3Modal.default;
            const WalletConnectProvider = window.WalletConnectProvider.default;
            const evmChains = window.evmChains;

            // Web3modal instance
            let web3Modal;

            // Tell Web3modal what providers we have available.
            // Built-in web browser provider (only one can exist as a time)
            // like MetaMask, Brave or Opera is added automatically by Web3modal
            const providerOptions = {
                /*  walletconnect: {
                    package: WalletConnectProvider, //This should work only with HTTPS
                    options: {
                      // Mikko's test key - don't copy as your mileage may vary  //8043bb2cf99347b1bfadfb233c5325c0
                      infuraId: "27e484dcd9e3efcfd25a83a78777cdf1", //a1d145ed2a82409a8a4371b4861f89cf
                    }
                  } */
            };

            web3Modal = new Web3Modal({
                network: "matic",
                cacheProvider: true, // optional
                providerOptions, // required
                disableInjectedProvider: false, // optional. For MetaMask / Brave / Opera.
            });

            // providerX = web3Modal.connect();


            var primaryChain = null;

            if (window.ethereum) {
                web3 = new Web3(window.ethereum);

                primaryChain = window.ethereum;
            } else {
                alert('Crypto wallet not found')
            }


            function getVoteWeight(walletAddress) {
                console.log('getVoteWeight!!!!!!!');
                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function () {
                    console.log('state change!!!');
                    if (this.readyState == 4 && this.status == 200) {
                        console.log('query response!');
                        console.log(xhttp.responseText);
                        // Typical action to be performed when the document is ready:
                        // document.getElementById("demo").innerHTML = xhttp.responseText;

                        var result = JSON.parse(xhttp.responseText);

                        console.log(result);

                        var token_balance = result.token_balance;
                        var voteWeight = result.voteWeight;

                        $('#mm_balance_num').text(token_balance);
                        $('#vote_weight_num').text(voteWeight);
                    }
                };
                xhttp.open("GET", "/getvoteweight?walletAddress=" + walletAddress, true);
                xhttp.send();
            }

            function fetchAccountData(callback) {
                // Get a Web3 instance for the wallet
                web3 = new Web3(provider);

                web3.eth.getAccounts().then(function (accounts) {
                    console.log('Got accounts! ' + accounts);
                    // MetaMask does not give you all accounts, only the selected account
                    selectedAccount = accounts[0];

                    console.log('Connected wallet address: ' + accounts[0]);

                    getVoteWeight(selectedAccount);

                    if (callback) {
                        callback(selectedAccount);
                    }
                });
            }

            function connectProvider(callback) {
                web3Modal.connect().then(function (aProvider) {
                    provider = aProvider;

                    console.log('Got provider! ' + provider);

                    fetchAccountData(callback);

                    // Get connected chain id from Ethereum node
                    //web3.eth.getChainId().then(function (chainId) {
                    // Load chain information over an HTTP API
                    //const chainData = evmChains.getChain(chainId);
                    // document.querySelector("#network-name").textContent = chainData.name;

                    // Get list of accounts of the connected wallet

                    /*
                    const signer = provider.getSigner();

                    signer.getAddress().then((walletAddress) => {
                        console.log('signer wallet address: ' + walletAddress);
                    });
                    */
                    //});


                });
            }

            // load your wallet stats if already connected
            try {
                if (web3.eth) {
                    web3.eth.getAccounts().then(function (accounts) {
                        if (ethereum.selectedAddress) {//still the best way to detect if metamask is connected.
                            console.log('Got accounts!!! ' + accounts);
                            // MetaMask does not give you all accounts, only the selected account
                            selectedAccount = accounts[0];

                            console.log('Connected wallet address: ' + accounts[0]);
                            $('#btn-connect-wallet').text("Wallet connected");

                            getVoteWeight(selectedAccount);
                        }
                    });
                }
            } catch (e) {
                console.error(e);
            }



            $('#btn-connect-wallet').click(function () {
                connectProvider(function () {
                    console.log('Provider connected');
                    $('#btn-connect-wallet').text("Wallet connected");
                });
            });

            function submitProposal(title, description) {
                console.log('submitProposal 1!!!');

                connectProvider((walletAddress) => {
                    console.log('submitProposal 2!!!');
                    // walletAddress = Web3.utils.toChecksumAddress(walletAddress);

                    // we are normalizing the wallet address by lower casing it
                    // argument is that this is fine for computer code / database, the checksum address is mainly for humans
                    walletAddress = walletAddress.toLowerCase();

                    console.log('walletAddress for submitProposal: ' + walletAddress);

                    var signPromise = null;

                    var message = "New proposal:\n" + title + "\n" + description; // TODO: temp variable, remove/adjust, maybe a more "secure" message

                    // TODO: add more signature verification on proposals, to make sure that wallet address actually submitted the proposal

                    var bcaddr = walletAddress; // user blockchain address
                    var password = '';
                    web3.eth.personal.sign(message, bcaddr, password, function (err, signature) {
                        console.log('submitProposal 3!!!');

                        if (err) { console.log("Signature Denied"); }
                        if (signature) {
                            console.log('submitProposal 4!!!');

                            console.log('signature! ' + signature);

                            var signedWalletAddress = signature;

                            // alert('signedVoteValue: ' + signedVoteValue);

                            var xhr = new XMLHttpRequest();
                            xhr.open("POST", '/submitproposal', true);
                            xhr.setRequestHeader('Content-Type', 'application/json');

                            xhr.onreadystatechange = function () {
                                if (xhr.readyState == XMLHttpRequest.DONE) {
                                    console.log('submitProposal 5!!!');

                                    console.log('response: ' + xhr.responseText);

                                    if (xhr.status == 200) {
                                        // TODO: go to a vote successful page, helps a bit to prevent people to vote multiple times
                                        // TODO: when doing vote calculation, need to get rid of other votes from the same person, only pick 1 (probably the latest one)
                                        alert('Proposal submitted successfully')
                                    } else {
                                        alert('Proposal submission failed, please try again')
                                    }
                                }
                            }

                            xhr.send(JSON.stringify({
                                techlead: 'knows dae wae! üòé',
                                signedWalletAddress: signedWalletAddress,
                                walletAddress: walletAddress,
                                title: title,
                                description: description
                            }));
                        }
                    });

                    /*
                    signPromise = signer.signMessage(message);

                    console.log('signPromise: ' + signPromise);

                    signPromise.then((signedTransaction) => {

                        console.log('signedTransaction: ' + signedTransaction);
                        // "0xf86c808504a817c8008252089488a5c2d9919e46f883eb62f7b8dd9d0cc45bc2
                        //    90880de0b6b3a76400008025a05e766fa4bbb395108dc250ec66c2f88355d240
                        //    acdc47ab5dfaad46bcf63f2a34a05b2cb6290fd8ff801d07f6767df63c1c3da7
                        //    a7b83b53cd6cea3d3075ef9597d5"

                        var signedVoteValue = signedTransaction;

                        // alert('signedVoteValue: ' + signedVoteValue);

                        var xhr = new XMLHttpRequest();
                        xhr.open("POST", '/submitvote', true);
                        xhr.setRequestHeader('Content-Type', 'application/json');

                        xhr.onreadystatechange = function () {
                            if (xhr.readyState == XMLHttpRequest.DONE) {
                                console.log('response: ' + xhr.responseText);

                                if (xhr.status == 200) {
                                    // TODO: go to a vote successful page, helps a bit to prevent people to vote multiple times
                                    // TODO: when doing vote calculation, need to get rid of other votes from the same person, only pick 1 (probably the latest one)
                                    alert('Vote submitted successfully')
                                } else {
                                    alert('Vote submission failed, please try again')
                                }
                            }
                        }

                        xhr.send(JSON.stringify({
                            voteClass: voteClass,
                            voteValue: voteValue,
                            signedVoteValue: signedVoteValue,
                            walletAddress: walletAddress
                        }));
                    });
                    */
                });
            }

            $("#proposal_form").submit(function (event) {
                // alert("Handler for .submit() called.");

                var title = $('#proposal_title_input').val();
                var description = $('#proposal_description_input').val();

                // alert(title);
                // alert(description);

                submitProposal(title, description);

                event.preventDefault();
            });

            var globalProposals = {};

            var globalSelectedProposal = null;

            function proposalIdClick(proposalId) {
                // alert(proposalId);

                // TECHLEAD!!!!!!!!!!!

                var item = globalProposals[proposalId];

                globalSelectedProposal = item;

                var proposalId = item.proposalId;
                var proposalType = item.proposalType;
                var creationTime = item.creationTime;
                var title = item.title;
                var description = item.description;

                //$('#single_proposal_title').text(title);
                //$('#single_proposal_description').html('');
                //$('#single_proposal_description').text(description);

                var voteClass = proposalId;

                techleadVotesTablleeeeee(voteClass);

                getVoteStats(voteClass);
            }

            window.proposalIdClick = proposalIdClick;

            function techleadViewProposals() {
                console.log('Yo TechLead!!!!!!!');
                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function () {
                    console.log('state change!!!');
                    if (this.readyState == 4 && this.status == 200) {
                        console.log('query response!');
                        console.log(xhttp.responseText);
                        // Typical action to be performed when the document is ready:
                        // document.getElementById("demo").innerHTML = xhttp.responseText;

                        var result = JSON.parse(xhttp.responseText);

                        var items = result.items;
                        if (items) {
                            for (var i = 0; i < items.length; i++) {
                                var item = items[i];
                                console.log(item);

                                var proposalId = item.proposalId;
                                var proposalType = item.proposalType;
                                var creationTime = item.creationTime;
                                var title = item.title;
                                var description = item.description;

                                globalProposals[proposalId] = item;

                                // TODO: make creationDate prettier/more human readable
                                var creationDate = new Date(parseInt(creationTime));
                                console.log(creationDate);

                                var html = '<tr>';
                                html += '<td>' + creationTime + '</td>';
                                html += '<td onclick="proposalIdClick(\'' + proposalId + '\');"><a href="#' + proposalId + '">' + proposalId + '</a></td>';
                                html += '<td>' + title + '</td>';
                                html += '<td>' + description + '</td>';
                                html += '</tr>';

                                $('#proposals_table_tbody').append(html);
                            }
                        }

                        //var totalVoteCount = result.count;
                        //$('#total_vote_count_num').text(totalVoteCount);
                    }
                };
                xhttp.open("GET", "/privacyproposalquery", true);
                xhttp.send();
            }

            techleadViewProposals();

            function submitVote(voteClass, voteValue) {
                connectProvider((walletAddress) => {
                    // walletAddress = Web3.utils.toChecksumAddress(walletAddress);

                    // we are normalizing the wallet address by lower casing it
                    // argument is that this is fine for computer code / database, the checksum address is mainly for humans
                    walletAddress = walletAddress.toLowerCase();

                    console.log('walletAddress for vote submission: ' + walletAddress);

                    // var from = walletAddress;
                    var message = voteValue; // TODO: see comments in server.js, should hash on more info to be safe

                    // console.log('msgHash: ' + msgHash);

                    var signPromise = null;

                    // Note: Why we don't support Binance wallet (uses old eth_sign message which may be insecure)
                    // Binance only supports eth_sign now
                    // Note that eth_sign shows following warning on MetaMask: "Signing this message can have dangerous side effects. Only sign messages from sites you fully trust with your entire account. This dangerous method will be removed in a future version."
                    // This reddit explains that eth_sign can be used to sign things maliciously: https://www.reddit.com/r/ethdev/comments/llvdqa/any_risk_in_simply_signing_a_message_on_ethereum/
                    // Binance doc on eth_sign: https://docs.binance.org/smart-chain/wallet/wallet_api.html#using-the-provider
                    //
                    // signPromise = primaryChain.request({
                    //     method: "eth_sign",
                    //     params: [from, message]
                    // });


                    // TODO: gray out voting if wallet not connected, or something like that
                    // basically ideally don't want user to start the voting process without having a wallet connected

                    var bcaddr = walletAddress; // user blockchain address
                    var password = '';
                    web3.eth.personal.sign(message, bcaddr, password, function (err, signature) {
                        if (err) { console.log("Signature Denied"); }
                        if (signature) {

                            console.log('signature! ' + signature);

                            var signedVoteValue = signature;

                            // alert('signedVoteValue: ' + signedVoteValue);

                            var xhr = new XMLHttpRequest();
                            xhr.open("POST", '/submitvote', true);
                            xhr.setRequestHeader('Content-Type', 'application/json');

                            xhr.onreadystatechange = function () {
                                if (xhr.readyState == XMLHttpRequest.DONE) {
                                    console.log('response: ' + xhr.responseText);

                                    if (xhr.status == 200) {
                                        // TODO: go to a vote successful page, helps a bit to prevent people to vote multiple times
                                        // TODO: when doing vote calculation, need to get rid of other votes from the same person, only pick 1 (probably the latest one)
                                        alert('Vote submitted successfully, please refresh the page to see the update in the Voting Stats and Recent Votes sections')
                                    } else {
                                        alert('Vote submission failed, please try again')
                                    }
                                }
                            }

                            xhr.send(JSON.stringify({
                                voteClass: voteClass,
                                voteValue: voteValue,
                                signedVoteValue: signedVoteValue,
                                walletAddress: walletAddress
                            }));
                        }
                    });

                    /*
                    signPromise = signer.signMessage(message);

                    console.log('signPromise: ' + signPromise);

                    signPromise.then((signedTransaction) => {

                        console.log('signedTransaction: ' + signedTransaction);
                        // "0xf86c808504a817c8008252089488a5c2d9919e46f883eb62f7b8dd9d0cc45bc2
                        //    90880de0b6b3a76400008025a05e766fa4bbb395108dc250ec66c2f88355d240
                        //    acdc47ab5dfaad46bcf63f2a34a05b2cb6290fd8ff801d07f6767df63c1c3da7
                        //    a7b83b53cd6cea3d3075ef9597d5"

                        var signedVoteValue = signedTransaction;

                        // alert('signedVoteValue: ' + signedVoteValue);

                        var xhr = new XMLHttpRequest();
                        xhr.open("POST", '/submitvote', true);
                        xhr.setRequestHeader('Content-Type', 'application/json');

                        xhr.onreadystatechange = function () {
                            if (xhr.readyState == XMLHttpRequest.DONE) {
                                console.log('response: ' + xhr.responseText);

                                if (xhr.status == 200) {
                                    // TODO: go to a vote successful page, helps a bit to prevent people to vote multiple times
                                    // TODO: when doing vote calculation, need to get rid of other votes from the same person, only pick 1 (probably the latest one)
                                    alert('Vote submitted successfully')
                                } else {
                                    alert('Vote submission failed, please try again')
                                }
                            }
                        }

                        xhr.send(JSON.stringify({
                            voteClass: voteClass,
                            voteValue: voteValue,
                            signedVoteValue: signedVoteValue,
                            walletAddress: walletAddress
                        }));
                    });
                    */
                });
            }

            $("#voteButton").click(function () {
                var radioValue = $("input[name='voteOptions']:checked").val();
                if (radioValue) {
                    // alert("Your are a - " + radioValue);

                    var voteClass = null;
                    if (globalSelectedProposal) {
                        voteClass = globalSelectedProposal.proposalId;
                    } else {
                        voteClass = hardcodedProposal;
                    }

                    submitVote(voteClass, radioValue);
                }
            });

            function techleadVotesTablleeeeee(currentVoteClass) {
                // clear recent votes table
                $('#votes_table_tbody').html('');

                console.log('Yo!!!!!!!');
                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function () {
                    console.log('state change!!!');
                    if (this.readyState == 4 && this.status == 200) {
                        console.log('query response!');
                        console.log(xhttp.responseText);
                        // Typical action to be performed when the document is ready:
                        // document.getElementById("demo").innerHTML = xhttp.responseText;

                        var result = JSON.parse(xhttp.responseText);

                        var items = result.items;
                        if (items) {
                            for (var i = 0; i < items.length; i++) {
                                var item = items[i];
                                console.log(item);

                                var voteClass = item.voteClass;
                                var obscuredWalletAddress = item.obscuredWalletAddress;
                                var creationTime = item.creationTime; // in epoch milli
                                var voteValue = item.voteValue;
                                var voteWeight = item.voteWeight;

                                // TODO: make creationDate prettier/more human readable
                                var creationDate = new Date(parseInt(creationTime));
                                console.log(creationDate);

                                var html = '<tr>';
                                html += '<td>' + creationDate + '</td>';
                                html += '<td>' + obscuredWalletAddress + '</td>';
                                html += '<td>' + voteValue + '</td>';
                                html += '<td>' + voteWeight + '</td>';
                                html += '</tr>';

                                $('#votes_table_tbody').append(html);
                            }
                        }

                        // var totalVoteCount = result.count;
                        // $('#total_vote_count_num').text(totalVoteCount);
                    }
                };
                // var currentVoteClass = 'matrix';
                xhttp.open("GET", "/privacyvotequery?voteClass=" + currentVoteClass, true);
                xhttp.send();
            }

            techleadVotesTablleeeeee(hardcodedProposal);

            function getVoteStats(currentVoteClass) {
                // clear recent votes table
                // $('#votes_table_tbody').html('');

                console.log('getVoteStats!');

                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function () {
                    console.log('state change!!!');
                    if (this.readyState == 4 && this.status == 200) {
                        console.log('query response!');
                        console.log(xhttp.responseText);
                        // Typical action to be performed when the document is ready:
                        // document.getElementById("demo").innerHTML = xhttp.responseText;

                        var result = JSON.parse(xhttp.responseText);

                        console.log(result);

                        // TODO: for now, assume 'Yes' and 'No' are the vote values
                        var sum = result.sum;
                        var count = result.count;

                        var yes_weight = 0;
                        var no_weight = 0;

                        if (sum['Yes']) {
                            yes_weight = sum['Yes'];
                        }

                        if (sum['No']) {
                            no_weight = sum['No'];
                        }

                        var total_weight = yes_weight + no_weight;


                        // Add pie chart

                        if (window.myChart instanceof Chart) {
                            window.myChart.destroy();
                        }

                        var ctx = document.getElementById('myChart').getContext('2d');

                        window.myChart = new Chart(ctx, {
                            type: 'pie',
                            data: {
                                labels: ['Yes', 'No'],
                                datasets: [{
                                    label: '# of Votes',
                                    data: [yes_weight, no_weight],
                                    backgroundColor: [
                                        '#ff6484',
                                        '#36a2eb'
                                    ]
                                }]
                            },
                            options: {
                                plugins: {
                                    title: {
                                        display: true,
                                        text: 'Total Vote Weight'
                                    }
                                }
                            }
                            // responsive: true,
                            // maintainAspectRatio: false
                        });


                        var totalVoteCount = count;
                        $('#total_vote_count_num').text(totalVoteCount);

                        $('#total_vote_weight_num').text(total_weight);
                    }
                };
                // var currentVoteClass = 'matrix';
                xhttp.open("GET", "/getvotestats?voteClass=" + currentVoteClass, true);
                xhttp.send();
            }

            getVoteStats(hardcodedProposal);
        }

        // TODO: surface error messages if vote failed. Especially, this is in case there is high traffic and we get throttled

        $(document).ready(function () {
            init();
        });



        /*

        // Connect with wallet: https://stackoverflow.com/questions/60785630/how-to-connect-ethers-js-with-metamask
        // enable() is deprecated: https://ethereum.stackexchange.com/questions/92095/web3-current-best-practice-to-connect-metamask-to-chrome/92097
        let provider;
        // window.ethereum.enable().then(provider = new ethers.providers.Web3Provider(window.ethereum));
        // primaryChain.request({ method: 'eth_requestAccounts' }).then(provider = new ethers.providers.Web3Provider(primaryChain));

        primaryChain.request({ method: 'eth_requestAccounts' }).then(provider = new ethers.providers.Web3Provider(primaryChain));

        const signer = provider.getSigner();

        function submitVote(voteClass, voteValue) {
            signer.getAddress().then((walletAddress) => {
                console.log('walletAddress: ' + walletAddress);

                var from = walletAddress;
                var message = voteValue;

                // console.log('msgHash: ' + msgHash);

                var signPromise = null;

                // Note: Why we don't support Binance wallet (uses old eth_sign message which may be insecure)
                // Binance only supports eth_sign now
                // Note that eth_sign shows following warning on MetaMask: "Signing this message can have dangerous side effects. Only sign messages from sites you fully trust with your entire account. This dangerous method will be removed in a future version."
                // This reddit explains that eth_sign can be used to sign things maliciously: https://www.reddit.com/r/ethdev/comments/llvdqa/any_risk_in_simply_signing_a_message_on_ethereum/
                // Binance doc on eth_sign: https://docs.binance.org/smart-chain/wallet/wallet_api.html#using-the-provider
                //
                // signPromise = primaryChain.request({
                //     method: "eth_sign",
                //     params: [from, message]
                // });

                signPromise = signer.signMessage(message);

                console.log('signPromise: ' + signPromise);

                signPromise.then((signedTransaction) => {

                    console.log('signedTransaction: ' + signedTransaction);
                    // "0xf86c808504a817c8008252089488a5c2d9919e46f883eb62f7b8dd9d0cc45bc2
                    //    90880de0b6b3a76400008025a05e766fa4bbb395108dc250ec66c2f88355d240
                    //    acdc47ab5dfaad46bcf63f2a34a05b2cb6290fd8ff801d07f6767df63c1c3da7
                    //    a7b83b53cd6cea3d3075ef9597d5"

                    var signedVoteValue = signedTransaction;

                    // alert('signedVoteValue: ' + signedVoteValue);

                    var xhr = new XMLHttpRequest();
                    xhr.open("POST", '/submitvote', true);
                    xhr.setRequestHeader('Content-Type', 'application/json');

                    xhr.onreadystatechange = function () {
                        if (xhr.readyState == XMLHttpRequest.DONE) {
                            console.log('response: ' + xhr.responseText);

                            if (xhr.status == 200) {
                                // TODO: go to a vote successful page, helps a bit to prevent people to vote multiple times
                                // TODO: when doing vote calculation, need to get rid of other votes from the same person, only pick 1 (probably the latest one)
                                alert('Vote submitted successfully')
                            } else {
                                alert('Vote submission failed, please try again')
                            }
                        }
                    }

                    xhr.send(JSON.stringify({
                        voteClass: voteClass,
                        voteValue: voteValue,
                        signedVoteValue: signedVoteValue,
                        walletAddress: walletAddress
                    }));
                });
            });
        }


        $(document).ready(function () {
            $("#voteButton").click(function () {
                var radioValue = $("input[name='voteOptions']:checked").val();
                if (radioValue) {
                    // alert("Your are a - " + radioValue);

                    submitVote('matrix', radioValue);
                }
            });
        });
        */
    </script>

</head>

<body>

    <!-- Begin page content -->
    <main class="flex-shrink-0">
        <div class="container">
            <p style="margin-top: 20px;">
                <a href="https://www.liongov.io/">üè† LionGov.io Home Page</a>
            </p>
            <p>
                <button class="btn btn-outline-primary" id="btn-connect-wallet">
                    Connect wallet
                </button>
            </p>
            <h1 class="mt-5">LionGov v1.2 (Alpha)</h1>

            <p>
                LionGov is open source! Github repo: <a
                    href="https://github.com/LionGovIO/LionGov">https://github.com/LionGovIO/LionGov</a>
            </p>

            <div style="display: none;">

                <br />

                <p>
                <h4>Submit Proposal</h4>

                <p>
                    Note: This creates a proposal with "Yes" or "No" as the options. More proposal types will be
                    supported
                    in the future.
                </p>
                <p>
                <form id="proposal_form">
                    <div class="form-group">
                        <label for="exampleInputEmail1">Title</label>
                        <input type="text" class="form-control" id="proposal_title_input" aria-describedby="emailHelp"
                            placeholder="">
                    </div>
                    <div class="form-group">
                        <label for="exampleInputPassword1">Description</label>
                        <input type="text" class="form-control" id="proposal_description_input" placeholder="">
                    </div>
                    <button type="submit" class="btn btn-primary">Submit</button>
                </form>
                </p>
                </p>

                <br />

                <p>
                <h4>View Proposals</h4>
                <p>
                    Note: This list may be truncated, need to support viewing of all proposal. Also, ideally should make
                    the
                    proposal ID more human friendly.
                </p>

                <p>
                <table class="table table-sm">
                    <thead>
                        <tr>
                            <th scope="col">Time</th>
                            <th scope="col">Proposal ID</th>
                            <th scope="col">Title</th>
                            <th scope="col">Description</th>
                        </tr>
                    </thead>
                    <tbody id="proposals_table_tbody">
                    </tbody>
                </table>
                </p>
                </p>

                <div style="margin-top: 40px; margin-bottom: 40px;">
                    <hr />
                </div>

            </div>

            <br />

            <div class="alert alert-danger" role="alert">
                If you are unable to vote due to having an unsupported wallet or for other reasons, please enter your Polygon address using this form: <a href="https://forms.gle/j1JTpeq6QsQGUWPR7">https://forms.gle/j1JTpeq6QsQGUWPR7</a>
            </div>

            <br />

            <div class="card text-center" style="width: 550px;">
                <div class="card-body">
                    <h5 class="card-title">Proposal Voting Time Remaining</h5>
                    <p id="demo" class="display-4"></p>
                </div>
            </div>

            <br />

            <script>
                const countDownDate = new Date("Sat Oct 09 2021 21:30:00 GMT-0500").getTime();
            </script>

            <script>
                // Set the date we're counting down to
                // var countDownDate = new Date("Tue Oct 05 2021 21:30:00 GMT-0500").getTime();

                // Update the count down every 1 second
                var x = setInterval(function () {

                    // Get today's date and time
                    var now = new Date().getTime();

                    // Find the distance between now and the count down date
                    var distance = countDownDate - now;

                    // Time calculations for days, hours, minutes and seconds
                    var days = Math.floor(distance / (1000 * 60 * 60 * 24));
                    var hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                    var minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                    var seconds = Math.floor((distance % (1000 * 60)) / 1000);

                    // Display the result in the element with id="demo"
                    document.getElementById("demo").innerHTML = days + "d " + hours + "h "
                        + minutes + "m " + seconds + "s ";

                    // If the count down is finished, write some text
                    if (distance < 0) {
                        clearInterval(x);
                        document.getElementById("demo").innerHTML = "Proposal voting has ended!";
                    }
                }, 1000);
            </script>

            <div class="alert alert-info" role="alert">
                Everyone who votes on this proposal (yes or no) will receive high priority for a more rare NFT in the
                randomization. The goal is to reduce risk of airdropping rare NFTs on dead addresses.
            </div>

            <div style="height: 2px;">
            </div>

            <hr />


            <h3>Proposal</h3>

            <div class="alert alert-primary" role="alert">

                <p class="lead" style="margin-top: 20px;">
                    <b id="single_proposal_title">Should the AntiChin-Furries & CHIN Council settle their dispute with
                        an
                        epic rap battle? (Vote for a more rare NFT Lion Run airdrop)</b>
                </p>

                <p class="lead">
                <div id="single_proposal_description">
                    <p>
                        The Million Token community has been enthralled with a new epic drama. It's up to you to decide
                        whether they should settle their dispute with a rap battle. Vote Yes to settle this in a rap
                        battle.
                        Vote No if they need to settle this in another way.
                    </p>

                    <p>
                        The accusation from the AntiChin-Furries: They shouldn't get a million council seat because they
                        do
                        not have any service or use case. The word "chin" comes from the name of an actual user
                        (Chin#9747)
                        who is a ceritifed Dungeon Master known to have practiced MM FUD. This user was bitten by a
                        radioactive lemur and now spreading a virus throughout the community. Symptoms include cheese
                        overdose and severe price bleeding.
                    </p>

                    <p>
                        The defense from the CHIN Council: CHINs don't war. CHINS are an eternal love that will
                        encapsulate
                        everyone sooner or later and make them happy. CHINs have a CHINMAP which includes milestones
                        such as
                        Cheese Steaking and World Domination. They claim the 'chinening' has begun. They are a group of
                        brazen, loyal MM holders, out there to bring love and peace to the community.
                    </p>

                    <p>
                        AntiChin-Furries Links:<br />
                        <a href="https://discord.gg/6KVNbRNt">https://discord.gg/6KVNbRNt</a><br />
                        <a href="http://sayno2chin.com/">http://sayno2chin.com/</a>
                    </p>

                    <p>
                        CHIN Council Links:<br />
                        <a href="https://discord.gg/JBzRjf5c9d">https://discord.gg/JBzRjf5c9d</a><br />
                        <a href="https://chin.community/">https://chin.community/</a>
                    </p>

                    <p>
                        <b>
                            Everyone who votes on this proposal (yes or no) will receive high priority for a more rare
                            NFT
                            in the randomization. The goal is to reduce risk of airdropping rare NFTs on dead addresses.
                        </b>
                    </p>

                    <p>
                        Vote Yes if you want them to settle this in a rap battle. Vote No if you want them to settle
                        this in
                        another way.
                    </p>
                </div>
                </p>
            </div>
            <div class="form-check">
                <input class="form-check-input" type="radio" name="voteOptions" id="flexRadioDefault1" value="Yes">
                <label class="form-check-label" for="flexRadioDefault1">
                    <span>Yes</span>
                </label>
            </div>
            <div class="form-check">
                <input class="form-check-input" type="radio" name="voteOptions" id="flexRadioDefault2" value="No">
                <label class="form-check-label" for="flexRadioDefault2">
                    <span>No</span>
                </label>
            </div>
            </p>
            <p>
                <button type="button" id="voteButton" class="btn btn-primary btn-lg">Vote</button>
            </p>

            <br />

            <p>
                Notes:
            <ul>
                <li>You can only vote once with your wallet (currently if you vote twice, it will say it succeeded, but
                    your vote won't go through / won't show up in the Recent Votes section).</li>
                <li>After voting, please refresh the page to see updates in the Voting Stats and Recent Votes sections.
                    (We'll probably automate this in the future.)</li>
            </ul>
            </p>


            <br />

            <h4>Your Stats</h4>

            <p>
            <div>
                <i>MM balance:</i> <span id="mm_balance_num">N/A</span>
            </div>
            <div>
                <i>Vote weight (in points):</i> <span id="vote_weight_num">N/A</span>
            </div>
            </p>

            <p>
            <div>
                <i>[TODO: show what vote you made]</i>
            </div>
            </p>

            <br />

            <h4>Voting Stats</h4>

            <p style="width: 400px;">
                <canvas id="myChart" width="400" height="400"></canvas>
                <script>
                    /*
                    var ctx = document.getElementById('myChart').getContext('2d');
                    var myChart = new Chart(ctx, {
                        type: 'pie',
                        data: {
                            labels: ['Yes', 'No'],
                            datasets: [{
                                label: '# of Votes',
                                data: [50, 10],
                                backgroundColor: [
                                    '#ff6484',
                                    '#36a2eb'
                                ]
                            }]
                        },
                        responsive:true,
                        maintainAspectRatio: false
                    });
                    */
                </script>
            </p>

            <p>

                <i>Total vote count:</i> <span id="total_vote_count_num"></span><br />
                <i>Total vote weight:</i> <span id="total_vote_weight_num"></span>
            </p>

            <br />

            <h4>Recent Votes</h4>
            <p>
            <table class="table table-sm">
                <thead>
                    <tr>
                        <th scope="col">Time</th>
                        <th scope="col">Wallet</th>
                        <th scope="col">Vote</th>
                        <th scope="col">Weight (in points)</th>
                    </tr>
                </thead>
                <tbody id="votes_table_tbody">
                </tbody>
            </table>
            </p>
        </div>
    </main>

</body>

</html>
